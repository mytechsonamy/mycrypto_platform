
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>matching: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mytrader/trade-engine/internal/matching/engine.go (83.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// ============================================================================
// MYTRADER TRADE ENGINE - MATCHING ENGINE (Production Implementation)
// ============================================================================
// Component: Matching Engine with Price-Time Priority Algorithm
// Version: 2.0 (integrates with Day 3 OrderBook)
// Performance Target: 1,000+ matches/second
// Thread Safety: Full concurrency support with symbol-level locking
// ============================================================================

package matching

import (
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/shopspring/decimal"
        "github.com/mytrader/trade-engine/internal/domain"
        "github.com/mytrader/trade-engine/internal/orderbook"
)

// Error definitions
var (
        ErrInvalidOrder        = errors.New("invalid order")
        ErrInvalidQuantity     = errors.New("quantity must be greater than 0")
        ErrInvalidPrice        = errors.New("price must be greater than 0 for limit orders")
        ErrInvalidSymbol       = errors.New("invalid or empty symbol")
        ErrUnsupportedOrderType = errors.New("unsupported order type")
        ErrOrderNotFound       = errors.New("order not found")
        ErrCannotCancelOrder   = errors.New("order cannot be cancelled in current status")
        ErrFOKNotFilled        = errors.New("FOK order could not be filled completely")
        ErrInsufficientLiquidity = errors.New("insufficient liquidity to fill market order")
)

// MatchingEngine manages order books for multiple trading symbols and executes trades
// using the Price-Time Priority algorithm.
//
// ARCHITECTURE:
//   - Multi-Symbol Support: One engine manages all trading pairs
//   - Symbol-Level Locking: Each OrderBook has its own RWMutex (concurrent symbol trading)
//   - Engine-Level Locking: OrderBooks map protected by engine RWMutex
//   - Thread-Safe: Supports concurrent order placement across symbols
//
// PERFORMANCE:
//   - Target: 1,000+ matches/second
//   - OrderBook: 476K ops/sec (Day 3 benchmark)
//   - Latency: &lt;10ms (p99) for matching operations
//
// ALGORITHM: Price-Time Priority
//   1. Price Priority: Best prices matched first (highest bid, lowest ask)
//   2. Time Priority: FIFO at same price level (first order filled first)
//   3. Partial Fills: Orders can match across multiple price levels
//   4. Maker/Taker: Passive orders (in book) are makers, aggressive orders are takers
type MatchingEngine struct {
        // Order books mapped by symbol (e.g., "BTC/USDT" -&gt; OrderBook)
        orderBooks map[string]*orderbook.OrderBook
        mu         sync.RWMutex

        // Fee configuration (as decimal percentages)
        makerFeeRate decimal.Decimal // Default: 0.0005 (0.05%)
        takerFeeRate decimal.Decimal // Default: 0.0010 (0.10%)

        // Event callbacks (for async processing)
        onTrade       func(*domain.Trade)            // Called when trade executes
        onOrderUpdate func(*domain.Order)            // Called when order status changes

        // Metrics and statistics
        stats *EngineStatistics
        statsM sync.RWMutex
}

// EngineStatistics tracks matching engine metrics
type EngineStatistics struct {
        TradesExecuted   int64           // Total number of trades
        OrdersProcessed  int64           // Total orders processed
        TotalVolume      decimal.Decimal // Total volume matched (in quote currency)
        TotalFees        decimal.Decimal // Total fees collected
        LastUpdateTime   time.Time
        OrderBooksCount  int             // Number of active symbol order books
}

// NewMatchingEngine creates a new matching engine with default configuration
func NewMatchingEngine() *MatchingEngine <span class="cov8" title="1">{
        return &amp;MatchingEngine{
                orderBooks:   make(map[string]*orderbook.OrderBook),
                makerFeeRate: decimal.NewFromFloat(0.0005), // 0.05%
                takerFeeRate: decimal.NewFromFloat(0.0010), // 0.10%
                stats: &amp;EngineStatistics{
                        TotalVolume:    decimal.Zero,
                        TotalFees:      decimal.Zero,
                        LastUpdateTime: time.Now(),
                },
        }
}</span>

// SetFeeRates updates the maker and taker fee rates
func (me *MatchingEngine) SetFeeRates(makerRate, takerRate decimal.Decimal) <span class="cov0" title="0">{
        me.mu.Lock()
        defer me.mu.Unlock()

        me.makerFeeRate = makerRate
        me.takerFeeRate = takerRate
}</span>

// SetTradeCallback sets the callback function for trade events
func (me *MatchingEngine) SetTradeCallback(callback func(*domain.Trade)) <span class="cov0" title="0">{
        me.onTrade = callback
}</span>

// SetOrderUpdateCallback sets the callback function for order status updates
func (me *MatchingEngine) SetOrderUpdateCallback(callback func(*domain.Order)) <span class="cov0" title="0">{
        me.onOrderUpdate = callback
}</span>

// PlaceOrder is the main entry point for order matching.
// It validates the order, attempts to match it against the order book,
// and returns any trades that were executed.
//
// Returns:
//   - []*domain.Trade: List of trades executed (empty if no match)
//   - error: Validation or execution error
//
// Complexity: O(k * log n) where k is number of matched orders, n is price levels
func (me *MatchingEngine) PlaceOrder(order *domain.Order) ([]*domain.Trade, error) <span class="cov8" title="1">{
        // 1. Validate order
        if err := me.validateOrder(order); err != nil </span><span class="cov8" title="1">{
                order.Status = domain.OrderStatusRejected
                if me.onOrderUpdate != nil </span><span class="cov0" title="0">{
                        me.onOrderUpdate(order)
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        // 2. Initialize order state
        <span class="cov8" title="1">if order.ID == uuid.Nil </span><span class="cov0" title="0">{
                order.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">order.Status = domain.OrderStatusOpen
        order.FilledQuantity = decimal.Zero
        now := time.Now()
        if order.CreatedAt.IsZero() </span><span class="cov8" title="1">{
                order.CreatedAt = now
        }</span>
        <span class="cov8" title="1">order.UpdatedAt = now

        // 3. Get or create order book for symbol
        ob := me.getOrCreateOrderBook(order.Symbol)

        // 4. Match order based on type
        var trades []*domain.Trade
        var err error

        switch order.Type </span>{
        case domain.OrderTypeMarket:<span class="cov8" title="1">
                trades, err = me.matchMarketOrder(order, ob)</span>
        case domain.OrderTypeLimit:<span class="cov8" title="1">
                trades, err = me.matchLimitOrder(order, ob)</span>
        default:<span class="cov0" title="0">
                return nil, ErrUnsupportedOrderType</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                order.Status = domain.OrderStatusRejected
                if me.onOrderUpdate != nil </span><span class="cov0" title="0">{
                        me.onOrderUpdate(order)
                }</span>
                <span class="cov8" title="1">return trades, err</span>
        }

        // 5. Update order status based on fill
        <span class="cov8" title="1">if order.IsFilled() </span><span class="cov8" title="1">{
                order.Status = domain.OrderStatusFilled
        }</span> else<span class="cov8" title="1"> if order.IsPartiallyFilled() </span><span class="cov8" title="1">{
                order.Status = domain.OrderStatusPartiallyFilled
        }</span>

        // 6. Update statistics
        <span class="cov8" title="1">me.updateStatistics(trades, order)

        // 7. Trigger order update callback
        if me.onOrderUpdate != nil </span><span class="cov0" title="0">{
                me.onOrderUpdate(order)
        }</span>

        <span class="cov8" title="1">return trades, nil</span>
}

// CancelOrder cancels an open order in the order book
//
// Parameters:
//   - orderID: UUID of the order to cancel
//   - symbol: Trading symbol (e.g., "BTC/USDT")
//
// Returns error if order not found or cannot be cancelled
func (me *MatchingEngine) CancelOrder(orderID uuid.UUID, symbol string) error <span class="cov8" title="1">{
        ob := me.getOrCreateOrderBook(symbol)

        // Get order from order book
        order, err := ob.GetOrder(orderID)
        if err != nil </span><span class="cov8" title="1">{
                return ErrOrderNotFound
        }</span>

        // Check if order can be cancelled
        <span class="cov8" title="1">if !order.CanBeCancelled() </span><span class="cov0" title="0">{
                return ErrCannotCancelOrder
        }</span>

        // Remove from order book
        <span class="cov8" title="1">if err := ob.RemoveOrder(orderID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Update order status
        <span class="cov8" title="1">if err := order.Cancel(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Trigger callback
        <span class="cov8" title="1">if me.onOrderUpdate != nil </span><span class="cov0" title="0">{
                me.onOrderUpdate(order)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// matchMarketOrder matches a market order against the order book
//
// Market orders consume liquidity from the opposite side of the book:
//   - Market BUY: Matches against ask orders (sell side), walking up price levels
//   - Market SELL: Matches against bid orders (buy side), walking down price levels
//
// The order will match until:
//   1. Fully filled, OR
//   2. Order book exhausted (no more liquidity)
//
// For FOK (Fill-or-Kill) orders, the entire order must fill or it's rejected.
//
// Complexity: O(k * log n) where k is matched orders, n is price levels
func (me *MatchingEngine) matchMarketOrder(order *domain.Order, ob *orderbook.OrderBook) ([]*domain.Trade, error) <span class="cov8" title="1">{
        trades := make([]*domain.Trade, 0)
        remaining := order.Quantity

        // Determine opposite side to match against
        var getBestLevel func() (*orderbook.PriceLevel, error)
        if order.Side == domain.OrderSideBuy </span><span class="cov8" title="1">{
                getBestLevel = ob.GetBestAsk // Buy against sell orders
        }</span> else<span class="cov8" title="1"> {
                getBestLevel = ob.GetBestBid // Sell against buy orders
        }</span>

        // For FOK orders, pre-check if sufficient liquidity exists
        <span class="cov8" title="1">if order.TimeInForce == domain.TimeInForceFOK </span><span class="cov8" title="1">{
                availableLiquidity := decimal.Zero
                depth := ob.GetDepth(100) // Check up to 100 levels

                var levels []orderbook.PriceLevelSnapshot
                if order.Side == domain.OrderSideBuy </span><span class="cov8" title="1">{
                        levels = depth.Asks
                }</span> else<span class="cov0" title="0"> {
                        levels = depth.Bids
                }</span>

                <span class="cov8" title="1">for _, level := range levels </span><span class="cov8" title="1">{
                        vol, _ := decimal.NewFromString(level.Volume)
                        availableLiquidity = availableLiquidity.Add(vol)
                        if availableLiquidity.GreaterThanOrEqual(order.Quantity) </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">if availableLiquidity.LessThan(order.Quantity) </span><span class="cov8" title="1">{
                        // Insufficient liquidity for FOK
                        return nil, ErrFOKNotFilled
                }</span>
        }

        // Keep matching until order filled or book exhausted
        <span class="cov8" title="1">for remaining.IsPositive() </span><span class="cov8" title="1">{
                // Get best price level
                level, err := getBestLevel()
                if err != nil || level == nil </span><span class="cov8" title="1">{
                        // No more liquidity available
                        break</span>
                }

                // Match against orders at this price level (FIFO order - time priority)
                // Make a copy since updating the book modifies the underlying slice
                <span class="cov8" title="1">matchedOrders := make([]*domain.Order, len(level.Orders))
                copy(matchedOrders, level.Orders)

                if len(matchedOrders) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">for _, matchOrder := range matchedOrders </span><span class="cov8" title="1">{
                        if remaining.IsZero() </span><span class="cov8" title="1">{
                                break</span>
                        }

                        // Calculate fill quantity (minimum of what's needed and what's available)
                        <span class="cov8" title="1">fillQty := decimal.Min(remaining, matchOrder.RemainingQuantity())

                        // Create trade at this price level
                        trade := me.createTrade(order, matchOrder, level.Price, fillQty, false)
                        trades = append(trades, trade)

                        // Update incoming order
                        order.FilledQuantity = order.FilledQuantity.Add(fillQty)
                        remaining = remaining.Sub(fillQty)

                        // Update matched order in order book
                        if err := ob.UpdateOrder(matchOrder.ID, fillQty); err != nil </span><span class="cov0" title="0">{
                                // Order book handles removal if fully filled
                                return trades, fmt.Errorf("failed to update order in book: %w", err)
                        }</span>

                        // Trigger callbacks
                        <span class="cov8" title="1">if me.onOrderUpdate != nil </span><span class="cov0" title="0">{
                                me.onOrderUpdate(matchOrder)
                        }</span>
                        <span class="cov8" title="1">if me.onTrade != nil </span><span class="cov0" title="0">{
                                me.onTrade(trade)
                        }</span>
                }
        }

        <span class="cov8" title="1">return trades, nil</span>
}

// matchLimitOrder matches a limit order against the order book
//
// Limit orders have two phases:
//   1. TAKER PHASE: If price crosses (buy &gt;= ask or sell &lt;= bid), match immediately
//   2. MAKER PHASE: If not fully filled, add remaining quantity to book as maker order
//
// Price improvement is allowed: execution price can be better than limit price.
//
// Time-in-Force handling:
//   - GTC (Good-Till-Cancel): Remains in book until filled or cancelled
//   - IOC (Immediate-or-Cancel): Match immediately, cancel unfilled portion
//   - FOK (Fill-or-Kill): Fill completely or reject entire order
//
// Complexity: O(k * log n) where k is matched orders, n is price levels
func (me *MatchingEngine) matchLimitOrder(order *domain.Order, ob *orderbook.OrderBook) ([]*domain.Trade, error) <span class="cov8" title="1">{
        trades := make([]*domain.Trade, 0)
        remaining := order.Quantity

        // Determine matching conditions based on order side
        var getBestLevel func() (*orderbook.PriceLevel, error)
        var canMatch func(decimal.Decimal) bool

        if order.Side == domain.OrderSideBuy </span><span class="cov8" title="1">{
                getBestLevel = ob.GetBestAsk
                // Buy limit crosses if our price &gt;= ask price (price improvement possible)
                canMatch = func(askPrice decimal.Decimal) bool </span><span class="cov8" title="1">{
                        return order.Price.GreaterThanOrEqual(askPrice)
                }</span>
        } else<span class="cov8" title="1"> {
                getBestLevel = ob.GetBestBid
                // Sell limit crosses if our price &lt;= bid price (price improvement possible)
                canMatch = func(bidPrice decimal.Decimal) bool </span><span class="cov8" title="1">{
                        return order.Price.LessThanOrEqual(bidPrice)
                }</span>
        }

        // For FOK orders, pre-check if we can fill completely
        <span class="cov8" title="1">if order.TimeInForce == domain.TimeInForceFOK </span><span class="cov8" title="1">{
                availableLiquidity := decimal.Zero
                depth := ob.GetDepth(100)

                var levels []orderbook.PriceLevelSnapshot
                if order.Side == domain.OrderSideBuy </span><span class="cov8" title="1">{
                        levels = depth.Asks
                }</span> else<span class="cov0" title="0"> {
                        levels = depth.Bids
                }</span>

                <span class="cov8" title="1">for _, level := range levels </span><span class="cov8" title="1">{
                        levelPrice, _ := decimal.NewFromString(level.Price)
                        if !canMatch(levelPrice) </span><span class="cov0" title="0">{
                                break</span> // Price doesn't cross, stop
                        }
                        <span class="cov8" title="1">vol, _ := decimal.NewFromString(level.Volume)
                        availableLiquidity = availableLiquidity.Add(vol)
                        if availableLiquidity.GreaterThanOrEqual(order.Quantity) </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">if availableLiquidity.LessThan(order.Quantity) </span><span class="cov8" title="1">{
                        // Insufficient liquidity for FOK
                        return nil, ErrFOKNotFilled
                }</span>
        }

        // PHASE 1: TAKER - Try to match against existing orders
        <span class="cov8" title="1">for remaining.IsPositive() </span><span class="cov8" title="1">{
                level, err := getBestLevel()
                if err != nil || level == nil || !canMatch(level.Price) </span><span class="cov8" title="1">{
                        // No matching price available
                        break</span>
                }

                // Match against orders at this level (FIFO - time priority)
                // Make a copy since updating the book modifies the underlying slice
                <span class="cov8" title="1">matchedOrders := make([]*domain.Order, len(level.Orders))
                copy(matchedOrders, level.Orders)

                if len(matchedOrders) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">for _, matchOrder := range matchedOrders </span><span class="cov8" title="1">{
                        if remaining.IsZero() </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov8" title="1">fillQty := decimal.Min(remaining, matchOrder.RemainingQuantity())

                        // Create trade (incoming order is taker, matched order is maker)
                        trade := me.createTrade(order, matchOrder, level.Price, fillQty, false)
                        trades = append(trades, trade)

                        // Update incoming order
                        order.FilledQuantity = order.FilledQuantity.Add(fillQty)
                        remaining = remaining.Sub(fillQty)

                        // Update matched order in book
                        if err := ob.UpdateOrder(matchOrder.ID, fillQty); err != nil </span><span class="cov0" title="0">{
                                return trades, fmt.Errorf("failed to update order in book: %w", err)
                        }</span>

                        // Trigger callbacks
                        <span class="cov8" title="1">if me.onOrderUpdate != nil </span><span class="cov0" title="0">{
                                me.onOrderUpdate(matchOrder)
                        }</span>
                        <span class="cov8" title="1">if me.onTrade != nil </span><span class="cov0" title="0">{
                                me.onTrade(trade)
                        }</span>
                }
        }

        // PHASE 2: MAKER - Add remaining quantity to order book
        <span class="cov8" title="1">if remaining.IsPositive() </span><span class="cov8" title="1">{
                // Check Time-in-Force constraints
                switch order.TimeInForce </span>{
                case domain.TimeInForceIOC:<span class="cov8" title="1">
                        // Immediate-or-Cancel: Don't add to book, return partial fill
                        return trades, nil</span>

                case domain.TimeInForceGTC:<span class="cov8" title="1">
                        // Good-Till-Cancel: Add to book as maker
                        if err := ob.AddOrder(order); err != nil </span><span class="cov0" title="0">{
                                return trades, fmt.Errorf("failed to add order to book: %w", err)
                        }</span>

                case domain.TimeInForceFOK:<span class="cov0" title="0">
                        // FOK should have been handled in pre-check above
                        // This shouldn't happen since we validated upfront
                        return nil, ErrFOKNotFilled</span>
                }
        }

        <span class="cov8" title="1">return trades, nil</span>
}

// createTrade creates a trade record from two matching orders
//
// Parameters:
//   - incomingOrder: The aggressive order (taker)
//   - matchOrder: The passive order (maker, in the book)
//   - price: Execution price (always the maker's price)
//   - quantity: Fill quantity
//   - isIncomingMaker: Whether incoming order is maker (typically false for market/limit taker)
//
// Returns: Populated Trade struct with fees calculated
func (me *MatchingEngine) createTrade(
        incomingOrder, matchOrder *domain.Order,
        price, quantity decimal.Decimal,
        isIncomingMaker bool,
) *domain.Trade <span class="cov8" title="1">{
        trade := &amp;domain.Trade{
                ID:         uuid.New(),
                Symbol:     incomingOrder.Symbol,
                Price:      price,
                Quantity:   quantity,
                ExecutedAt: time.Now(),
        }

        // Determine buyer and seller based on incoming order side
        if incomingOrder.Side == domain.OrderSideBuy </span><span class="cov8" title="1">{
                // Incoming is buy order
                trade.BuyerOrderID = incomingOrder.ID
                trade.BuyerUserID = incomingOrder.UserID
                trade.SellerOrderID = matchOrder.ID
                trade.SellerUserID = matchOrder.UserID
                trade.IsBuyerMaker = isIncomingMaker
        }</span> else<span class="cov8" title="1"> {
                // Incoming is sell order
                trade.BuyerOrderID = matchOrder.ID
                trade.BuyerUserID = matchOrder.UserID
                trade.SellerOrderID = incomingOrder.ID
                trade.SellerUserID = incomingOrder.UserID
                trade.IsBuyerMaker = !isIncomingMaker
        }</span>

        // Calculate fees based on maker/taker roles
        <span class="cov8" title="1">tradeValue := price.Mul(quantity)

        if trade.IsBuyerMaker </span><span class="cov8" title="1">{
                // Buyer is maker (lower fee), seller is taker (higher fee)
                trade.BuyerFee = tradeValue.Mul(me.makerFeeRate)
                trade.SellerFee = tradeValue.Mul(me.takerFeeRate)
        }</span> else<span class="cov8" title="1"> {
                // Buyer is taker (higher fee), seller is maker (lower fee)
                trade.BuyerFee = tradeValue.Mul(me.takerFeeRate)
                trade.SellerFee = tradeValue.Mul(me.makerFeeRate)
        }</span>

        <span class="cov8" title="1">return trade</span>
}

// validateOrder validates order parameters before matching
func (me *MatchingEngine) validateOrder(order *domain.Order) error <span class="cov8" title="1">{
        if order == nil </span><span class="cov0" title="0">{
                return ErrInvalidOrder
        }</span>

        // Validate quantity
        <span class="cov8" title="1">if order.Quantity.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                return ErrInvalidQuantity
        }</span>

        // Validate symbol
        <span class="cov8" title="1">if order.Symbol == "" </span><span class="cov8" title="1">{
                return ErrInvalidSymbol
        }</span>

        // Validate side
        <span class="cov8" title="1">if !order.Side.IsValid() </span><span class="cov0" title="0">{
                return errors.New("invalid order side")
        }</span>

        // Validate type-specific requirements
        <span class="cov8" title="1">if order.Type == domain.OrderTypeLimit </span><span class="cov8" title="1">{
                if order.Price == nil || order.Price.LessThanOrEqual(decimal.Zero) </span><span class="cov8" title="1">{
                        return ErrInvalidPrice
                }</span>
        }

        // Validate time-in-force
        <span class="cov8" title="1">if !order.TimeInForce.IsValid() </span><span class="cov0" title="0">{
                return errors.New("invalid time in force")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// getOrCreateOrderBook gets or creates an order book for a symbol
// Thread-safe with engine-level locking
func (me *MatchingEngine) getOrCreateOrderBook(symbol string) *orderbook.OrderBook <span class="cov8" title="1">{
        // Try to get existing order book (read lock)
        me.mu.RLock()
        ob, exists := me.orderBooks[symbol]
        me.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                return ob
        }</span>

        // Create new order book (write lock)
        <span class="cov8" title="1">me.mu.Lock()
        defer me.mu.Unlock()

        // Double-check (another goroutine might have created it)
        if ob, exists := me.orderBooks[symbol]; exists </span><span class="cov0" title="0">{
                return ob
        }</span>

        // Create and store new order book
        <span class="cov8" title="1">ob = orderbook.NewOrderBook(symbol)
        me.orderBooks[symbol] = ob

        return ob</span>
}

// updateStatistics updates matching engine statistics
func (me *MatchingEngine) updateStatistics(trades []*domain.Trade, order *domain.Order) <span class="cov8" title="1">{
        me.statsM.Lock()
        defer me.statsM.Unlock()

        me.stats.TradesExecuted += int64(len(trades))
        me.stats.OrdersProcessed++

        for _, trade := range trades </span><span class="cov8" title="1">{
                volume := trade.Price.Mul(trade.Quantity)
                me.stats.TotalVolume = me.stats.TotalVolume.Add(volume)
                me.stats.TotalFees = me.stats.TotalFees.Add(trade.GetTotalFees())
        }</span>

        <span class="cov8" title="1">me.stats.LastUpdateTime = time.Now()</span>
}

// GetOrderBookSnapshot returns order book snapshot for a symbol
func (me *MatchingEngine) GetOrderBookSnapshot(symbol string, depth int) *orderbook.OrderBookDepth <span class="cov0" title="0">{
        ob := me.getOrCreateOrderBook(symbol)
        return ob.GetDepth(depth)
}</span>

// GetStatistics returns current matching engine statistics
func (me *MatchingEngine) GetStatistics() *EngineStatistics <span class="cov8" title="1">{
        me.statsM.RLock()
        defer me.statsM.RUnlock()

        me.mu.RLock()
        me.stats.OrderBooksCount = len(me.orderBooks)
        me.mu.RUnlock()

        // Return a copy to avoid race conditions
        statsCopy := *me.stats
        return &amp;statsCopy
}</span>

// GetOrderBook returns the order book for a symbol (for testing/debugging)
func (me *MatchingEngine) GetOrderBook(symbol string) *orderbook.OrderBook <span class="cov8" title="1">{
        return me.getOrCreateOrderBook(symbol)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
